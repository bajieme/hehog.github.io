(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{521:function(a,t,s){"use strict";s.r(t);var e=s(3),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"juc多线程及并发包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#juc多线程及并发包"}},[a._v("#")]),a._v(" JUC多线程及并发包")]),a._v(" "),s("h3",{attrs:{id:"进程和线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[a._v("#")]),a._v(" 进程和线程")]),a._v(" "),s("h4",{attrs:{id:"进程：和系统有关系，后台运行程序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程：和系统有关系，后台运行程序"}},[a._v("#")]),a._v(" 进程：和系统有关系，后台运行程序")]),a._v(" "),s("h4",{attrs:{id:"线程：依附于进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程：依附于进程"}},[a._v("#")]),a._v(" 线程：依附于进程")]),a._v(" "),s("h3",{attrs:{id:"多线程获取的方法-4种"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程获取的方法-4种"}},[a._v("#")]),a._v(" 多线程获取的方法(4种)")]),a._v(" "),s("ol",[s("li",[a._v("继承Thread类")]),a._v(" "),s("li",[a._v("实现Runable接口")]),a._v(" "),s("li",[a._v("Callable")]),a._v(" "),s("li",[a._v("Future")])]),a._v(" "),s("h4",{attrs:{id:"线程的6中状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程的6中状态"}},[a._v("#")]),a._v(" 线程的6中状态")]),a._v(" "),s("ol",[s("li",[a._v("NEW")]),a._v(" "),s("li",[a._v("RUNNABLE")]),a._v(" "),s("li",[a._v("BLOCKED")]),a._v(" "),s("li",[a._v("WAITING：一直等")]),a._v(" "),s("li",[a._v("TIMED_WAITING： 等一会就结束")]),a._v(" "),s("li",[a._v("TERMINATED")])]),a._v(" "),s("h4",{attrs:{id:"wait-和sleep-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#wait-和sleep-区别"}},[a._v("#")]),a._v(" wait()和sleep()区别")]),a._v(" "),s("ol",[s("li",[a._v("我会是线程进入blocked状态")]),a._v(" "),s("li",[a._v("wait释放锁 sleep不释放锁")])]),a._v(" "),s("h3",{attrs:{id:"volatile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[a._v("#")]),a._v(" volatile")]),a._v(" "),s("h4",{attrs:{id:"volatile是java虚拟机提供的轻量级的同步机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile是java虚拟机提供的轻量级的同步机制"}},[a._v("#")]),a._v(" volatile是Java虚拟机提供的轻量级的同步机制")]),a._v(" "),s("ol",[s("li",[a._v("保证可见性")]),a._v(" "),s("li",[a._v("不保证原子性")]),a._v(" "),s("li",[a._v("禁止指令重排序")])]),a._v(" "),s("h4",{attrs:{id:"jmm（java内存模型java-memory-model）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm（java内存模型java-memory-model）"}},[a._v("#")]),a._v(" JMM（Java内存模型Java Memory Model）")]),a._v(" "),s("p",[a._v("本身是一种抽象的概念 并不真实存在,它描述的是一组规则或规范通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式.JMM关于同步规定")]),a._v(" "),s("ol",[s("li",[a._v("线程解锁前,必须把共享变量的值刷新回"),s("code",[a._v("主内存")])]),a._v(" "),s("li",[a._v("线程加锁前,必须读取"),s("code",[a._v("主内存")]),a._v("的最新值到自己的"),s("code",[a._v("工作内存")])]),a._v(" "),s("li",[a._v("加锁解锁是同一把锁")])]),a._v(" "),s("p",[a._v("由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个"),s("code",[a._v("工作内存")]),a._v("(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而Java内存模型中规定所有变量都存储在"),s("code",[a._v("主内存")]),a._v(",主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在"),s("code",[a._v("工作内存")]),a._v("中进行,首先要将变量从"),s("code",[a._v("主内存")]),a._v("拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回"),s("code",[a._v("主内存")]),a._v(",不能直接操作"),s("code",[a._v("主内存")]),a._v("中的变量,各个线程中的"),s("code",[a._v("工作内存储")]),a._v("存着"),s("code",[a._v("主内存")]),a._v("中的变量副本拷贝,因此不同的线程无法访问对方的工作内存")]),a._v(" "),s("h4",{attrs:{id:"cas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[a._v("#")]),a._v(" CAS")]),a._v(" "),s("h5",{attrs:{id:"底层原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#底层原理"}},[a._v("#")]),a._v(" 底层原理")]),a._v(" "),s("ol",[s("li",[a._v("自旋锁")]),a._v(" "),s("li",[s("code",[a._v("Unsafe")]),a._v("类（通过本地"),s("code",[a._v("native")]),a._v("方法）")])]),a._v(" "),s("h5",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),s("ol",[s("li",[a._v("自旋开销CPU开销大")]),a._v(" "),s("li",[a._v("只能保证一个共享变量的原子操作")]),a._v(" "),s("li",[a._v("ABA问题 （线程1将 A 改成B 又改回了A）")])]),a._v(" "),s("h5",{attrs:{id:"解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[a._v("#")]),a._v(" 解决方案")]),a._v(" "),s("p",[a._v("原子应用（AtomicReference）")]),a._v(" "),s("h3",{attrs:{id:"collection"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[a._v("#")]),a._v(" Collection")]),a._v(" "),s("h5",{attrs:{id:"hashset-底层是hashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashset-底层是hashmap"}},[a._v("#")]),a._v(" HashSet 底层是HashMap")]),a._v(" "),s("h5",{attrs:{id:"hashtable-treemap-linkedhashmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashtable-treemap-linkedhashmap"}},[a._v("#")]),a._v(" HashTable TreeMap LinkedHashMap")]),a._v(" "),s("h3",{attrs:{id:"concurrenthashmap底层原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap底层原理"}},[a._v("#")]),a._v(" ConcurrentHashMap底层原理")]),a._v(" "),s("h3",{attrs:{id:"lock"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lock"}},[a._v("#")]),a._v(" Lock")]),a._v(" "),s("h5",{attrs:{id:"lock的理解：配合condition使用，精准通知，精准唤醒"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lock的理解：配合condition使用，精准通知，精准唤醒"}},[a._v("#")]),a._v(" lock的理解：配合Condition使用，精准通知，精准唤醒")]),a._v(" "),s("h5",{attrs:{id:"static-锁的是类，synchronized锁的是对象，sleep不释放锁，wait释放锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static-锁的是类，synchronized锁的是对象，sleep不释放锁，wait释放锁"}},[a._v("#")]),a._v(" static 锁的是类，synchronized锁的是对象，sleep不释放锁，wait释放锁")]),a._v(" "),s("h4",{attrs:{id:"锁升级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁升级"}},[a._v("#")]),a._v(" 锁升级")]),a._v(" "),s("h5",{attrs:{id:"偏向锁：锁只被一个线程持有"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁：锁只被一个线程持有"}},[a._v("#")]),a._v(" 偏向锁：锁只被一个线程持有")]),a._v(" "),s("h5",{attrs:{id:"轻量级锁：不同线程交替持有锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁：不同线程交替持有锁"}},[a._v("#")]),a._v(" 轻量级锁：不同线程交替持有锁")]),a._v(" "),s("h5",{attrs:{id:"重量级锁：多线程竞争锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁：多线程竞争锁"}},[a._v("#")]),a._v(" 重量级锁：多线程竞争锁")]),a._v(" "),s("h5",{attrs:{id:"jvm使用了锁的升级的优化方式，先试用偏向锁有同一线程再次获取锁，如果失败就升级为cas轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm使用了锁的升级的优化方式，先试用偏向锁有同一线程再次获取锁，如果失败就升级为cas轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁"}},[a._v("#")]),a._v(" jvm使用了锁的升级的优化方式，先试用偏向锁有同一线程再次获取锁，如果失败就升级为CAS轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起，最后如果以上都失败就升级为重量级锁")]),a._v(" "),s("h4",{attrs:{id:"reentrantlock是独占锁，semaphore-是共享锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock是独占锁，semaphore-是共享锁"}},[a._v("#")]),a._v(" ReentrantLock是独占锁，Semaphore 是共享锁")]),a._v(" "),s("ol",[s("li",[a._v("**公平锁：**并发环境中，每个线程会在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照先进先出的规则从队列中获取")]),a._v(" "),s("li",[a._v("**非公平锁：**上来就尝试占有锁，如果失败再按照公平锁的策略获取锁，吞吐量比公平锁大")]),a._v(" "),s("li",[a._v("**可重入锁（又名递归锁）：**指的是同一线程外层函数获得锁以后，内层递归韩式扔人能获取该锁的代码，在同一个线程外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，"),s("code",[a._v("线程可以今日任何一个它已经拥有的锁所同步的代码块")]),a._v("。主要作用："),s("code",[a._v("避免死锁")]),a._v("。")]),a._v(" "),s("li",[a._v("独占/共享锁")]),a._v(" "),s("li",[a._v("**自旋锁：**尝试获取锁的线程不会立即"),s("code",[a._v("阻塞")]),a._v("，而是采用"),s("code",[a._v("循环")]),a._v("的方式去尝试获取锁，这样的好处是"),s("code",[a._v("减少上下文的切换")]),a._v("，缺点是循环会"),s("code",[a._v("消耗CPU")])]),a._v(" "),s("li",[a._v("分段锁")])]),a._v(" "),s("h2",{attrs:{id:"链式编程-流式计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链式编程-流式计算"}},[a._v("#")]),a._v(" 链式编程+流式计算")]),a._v(" "),s("h2",{attrs:{id:"jvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" jvm")]),a._v(" "),s("p",[a._v("栈管运行，堆管存储")]),a._v(" "),s("p",[a._v("等号左边叫引用，等号右边叫实例对象，引用在栈中，实例对象在堆中")]),a._v(" "),s("h2",{attrs:{id:"aqs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[a._v("#")]),a._v(" AQS")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("高级语法")])]),a._v(" "),s("li",[s("p",[a._v("java集合类")])]),a._v(" "),s("li",[s("p",[a._v("java多线程")])]),a._v(" "),s("li",[s("p",[a._v("java io nip")])])]),a._v(" "),s("h2",{attrs:{id:"jvm-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm-2"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),s("h3",{attrs:{id:"一、类加载器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、类加载器"}},[a._v("#")]),a._v(" 一、类加载器")]),a._v(" "),s("ol",[s("li",[a._v("启动类加载器Bootstrap  C++ （java）")]),a._v(" "),s("li",[a._v("扩展类加载器Extension  Java (javax)")]),a._v(" "),s("li",[a._v("应用程序类加载器AppClassLoader")]),a._v(" "),s("li",[a._v("用户自定义")])]),a._v(" "),s("h3",{attrs:{id:"二、私有区域："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、私有区域："}},[a._v("#")]),a._v(" 二、私有区域：")]),a._v(" "),s("h4",{attrs:{id:"_1、本地方法栈native"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、本地方法栈native"}},[a._v("#")]),a._v(" 1、本地方法栈native")]),a._v(" "),s("h4",{attrs:{id:"_2、pc寄存器（program-counter-register），程序计数器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、pc寄存器（program-counter-register），程序计数器"}},[a._v("#")]),a._v(" 2、pc寄存器（Program Counter Register），程序计数器")]),a._v(" "),s("p",[a._v("记录了方法直接的调用和执行情况，类似排班值日用来储存指向吓一跳指令的地址，也即将要执行的指令代码，它是当前线程所执行的字节码行号指示器")]),a._v(" "),s("h4",{attrs:{id:"_3、java栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、java栈"}},[a._v("#")]),a._v(" 3、java栈")]),a._v(" "),s("h3",{attrs:{id:"三、共享区域（垃圾回收）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、共享区域（垃圾回收）"}},[a._v("#")]),a._v(" 三、共享区域（垃圾回收）")]),a._v(" "),s("h4",{attrs:{id:"_1、方法区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、方法区"}},[a._v("#")]),a._v(" 1、方法区")]),a._v(" "),s("ol",[s("li",[a._v("储存类的结构信息（模板），")]),a._v(" "),s("li",[a._v("不同的虚拟机实现不一样，最典型的是永久代（PermGen space）和元空间（Metaspace）")]),a._v(" "),s("li",[a._v("运行时常量池")]),a._v(" "),s("li",[a._v("实例变量存在堆中，和方法去无关")])]),a._v(" "),s("h4",{attrs:{id:"_2、堆（heap）默认物理机内存的-1-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、堆（heap）默认物理机内存的-1-4"}},[a._v("#")]),a._v(" 2、堆（heap）默认物理机内存的 1/4")]),a._v(" "),s("h5",{attrs:{id:"a、新生代（new-young）young-generation-space-1-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a、新生代（new-young）young-generation-space-1-3"}},[a._v("#")]),a._v(" a、新生代（new/young）Young Generation Space    1/3")]),a._v(" "),s("ol",[s("li",[a._v("伊甸园区(eden) GC = YGC （Minor GC） 8:1:1")]),a._v(" "),s("li",[a._v("幸存者0区 s0 = from")]),a._v(" "),s("li",[a._v("幸存者1区 s1 = to (s0 和 s1 每次GC后会交换，谁空谁是to)")])]),a._v(" "),s("h5",{attrs:{id:"b、老年代（old-tenure）tenure-generation-space-2-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b、老年代（old-tenure）tenure-generation-space-2-3"}},[a._v("#")]),a._v(" b、老年代（old/Tenure）Tenure generation space 2/3")]),a._v(" "),s("p",[a._v("Full GC = FGC")]),a._v(" "),s("h5",{attrs:{id:"c、元空间（metaspace）-永久代（permanent-space）-rt的jar包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c、元空间（metaspace）-永久代（permanent-space）-rt的jar包"}},[a._v("#")]),a._v(" c、元空间（Metaspace）/永久代（Permanent Space） rt的jar包")]),a._v(" "),s("p",[s("code",[a._v("java 8 元空间不在虚拟机中，而是使用本机物理内存")]),a._v("，字符串常量池移到元空间中")]),a._v(" "),s("h3",{attrs:{id:"三、execution-engine-执行引擎负责解释命令，提交操作系统执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、execution-engine-执行引擎负责解释命令，提交操作系统执行"}},[a._v("#")]),a._v(" 三、Execution Engine 执行引擎负责解释命令，提交操作系统执行")]),a._v(" "),s("h3",{attrs:{id:"谈谈对jvm的理解-java8的虚拟机有什么更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈对jvm的理解-java8的虚拟机有什么更新"}},[a._v("#")]),a._v(" 谈谈对JVM的理解 java8的虚拟机有什么更新")]),a._v(" "),s("h3",{attrs:{id:"什么是oom，什么事stackoverflowerror，有哪些方法分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是oom，什么事stackoverflowerror，有哪些方法分析"}},[a._v("#")]),a._v(" 什么是OOM，什么事StackOverflowError，有哪些方法分析")]),a._v(" "),s("h3",{attrs:{id:"jvm的常用参数调优你知道那些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm的常用参数调优你知道那些"}},[a._v("#")]),a._v(" JVM的常用参数调优你知道那些")]),a._v(" "),s("h3",{attrs:{id:"谈谈jvm中，对类加载器你的认识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#谈谈jvm中，对类加载器你的认识"}},[a._v("#")]),a._v(" 谈谈JVM中，对类加载器你的认识")]),a._v(" "),s("h3",{attrs:{id:"沙箱安全机制，双亲委派机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#沙箱安全机制，双亲委派机制"}},[a._v("#")]),a._v(" 沙箱安全机制，双亲委派机制")]),a._v(" "),s("h2",{attrs:{id:"gc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gc"}},[a._v("#")]),a._v(" GC")]),a._v(" "),s("h3",{attrs:{id:"分代收集算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分代收集算法"}},[a._v("#")]),a._v(" 分代收集算法")]),a._v(" "),s("p",[a._v("次数上频繁收集Young区")]),a._v(" "),s("p",[a._v("次数上较少收集Old区")]),a._v(" "),s("p",[a._v("基本不动元空间")]),a._v(" "),s("h3",{attrs:{id:"gc4大算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gc4大算法"}},[a._v("#")]),a._v(" GC4大算法")]),a._v(" "),s("ol",[s("li",[a._v("引用计数：基本不用户，可达性分析判断对象是否回收")]),a._v(" "),s("li",[a._v("复制算法：新生代，优：不会产生内存碎片，缺：耗内存")]),a._v(" "),s("li",[a._v("标记清除：老年代，内存碎片")]),a._v(" "),s("li",[a._v("标记压缩/整理：没碎片，需要移动对象的成本，浪费时间，效率不高")]),a._v(" "),s("li",[a._v("java8 以后G1")])]),a._v(" "),s("h3",{attrs:{id:"gc-root-如何确定的，那些对象可以作为gc-root"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gc-root-如何确定的，那些对象可以作为gc-root"}},[a._v("#")]),a._v(" GC Root 如何确定的，那些对象可以作为GC Root")]),a._v(" "),s("h4",{attrs:{id:"什么是垃圾：内存中已经不再被使用到的空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾：内存中已经不再被使用到的空间"}},[a._v("#")]),a._v(" 什么是垃圾：内存中已经不再被使用到的空间")]),a._v(" "),s("h4",{attrs:{id:"要进行垃圾回收如何判断一个对象是否是垃圾"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#要进行垃圾回收如何判断一个对象是否是垃圾"}},[a._v("#")]),a._v(" 要进行垃圾回收如何判断一个对象是否是垃圾")]),a._v(" "),s("ol",[s("li",[a._v("引用计数法，难以解决循环引用的问题")]),a._v(" "),s("li",[a._v("枚举根节点可达性分析（根搜索路径）")])]),a._v(" "),s("h4",{attrs:{id:"那些可以作为gc-root的对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#那些可以作为gc-root的对象"}},[a._v("#")]),a._v(" 那些可以作为GC Root的对象")]),a._v(" "),s("ol",[s("li",[a._v("虚拟机栈（栈中的局部变量区）中引用的对象")]),a._v(" "),s("li",[a._v("方法区中的类静态属性应用的对象")]),a._v(" "),s("li",[a._v("方法区中常量引用的对象")]),a._v(" "),s("li",[a._v("本地方法栈中（Native方法）引用的对象")])]),a._v(" "),s("h4",{attrs:{id:"如何查看jvm默认值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何查看jvm默认值"}},[a._v("#")]),a._v(" 如何查看jvm默认值")]),a._v(" "),s("div",{staticClass:"language-sh line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[a._v("java -XX:+PrintFlagsInitial 主要查看初始默认值\njava -XX:+PrintFlagsFinal -version 最终配置\njava -XX:+PrintCommandLineFlags -version 查看自定义配置内容\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 参数")]),a._v("\njava -Xms1024m -Xmx1024m -XX:+PrintGCDetails\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 常用调优参数 G1垃圾回收")]),a._v("\njava -Xms1024m -Xmx1024m -XX:+UseG1GC -XX:+PrintGCDetails\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 并行垃圾回收器 java8 默认")]),a._v("\njava -Xms1024m -Xmx1024m -XX:+UseParallelGC -XX:+PrintGCDetails\n\n\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br")])]),s("h4",{attrs:{id:"垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[a._v("#")]),a._v(" 垃圾回收器")]),a._v(" "),s("ol",[s("li",[a._v("SerialGC（串行）")]),a._v(" "),s("li",[a._v("ParallelGC（并行）")]),a._v(" "),s("li",[a._v("ParNewGC")]),a._v(" "),s("li",[a._v("ParallelOldGC")]),a._v(" "),s("li",[a._v("CMS（并发、标记、清除）：内存碎片")]),a._v(" "),s("li",[a._v("G1（9默认）：将堆内存分割成不同的区域然后并发的进行垃圾回收,没有碎片，停顿时间更短")]),a._v(" "),s("li",[a._v("ZGC（11以后）")])]),a._v(" "),s("h2",{attrs:{id:"es"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es"}},[a._v("#")]),a._v(" ES")]),a._v(" "),s("p",[a._v("倒排索引")]),a._v(" "),s("p",[a._v("B+树索引")]),a._v(" "),s("p",[a._v("精通jvm，对HotSpot虚拟机有较为深入的理解，有实际调优经验")]),a._v(" "),s("p",[a._v("项目中遇到的坑")]),a._v(" "),s("p",[a._v("redis 微服务 key 重复了")]),a._v(" "),s("p",[a._v("-Xms512m\n-Xmx1024m\n-XX:MaxPermSize=350m\n-XX:ReservedCodeCacheSize=512m\n-XX:+UseCompressedOops\n-Dfile.encoding=UTF-8\n-XX:+UseConcMarkSweepGC\n-XX:SoftRefLRUPolicyMSPerMB=50\n-ea\n-Dsun.io.useCanonCaches=false\n-Djava.net.preferIPv4Stack=true\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:-OmitStackTraceInFastThrow\n-Xverify:none")])])}),[],!1,null,null,null);t.default=v.exports}}]);